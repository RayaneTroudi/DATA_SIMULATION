import numpy as np
import scipy.stats as stats
import matplotlib.pyplot as plt

# ______________ HYPOTHESIS TESTING ______________ 
# H0 = X follows Gaussian Distribution (generated by Box-Muller transformation)
# H1 = X don't follows Gaussian Distribution  (generated by Box-Muller transformation)


#number of randoms values
size = 1000

#create sample of uniform distribution
random_uniform1 = np.random.uniform(0,1,size)
random_uniform2 = np.random.uniform(0,1,size)

#create sample of gaussien distribution N(0,1) by Box-Muller transform
observed_frequencies = np.sqrt(-2.0*np.log(random_uniform1))*np.cos(2.0*np.pi*random_uniform2)

mu = stats.tmean(observed_frequencies)
var = stats.tvar(observed_frequencies)
sigma = np.sqrt(var)



# number of class for independancy Khi2 test
number_classes = int(np.floor(1 + np.log2(size))+1)

#to avoid problem in extremities (a random value equal to an extremity)
epsilon = 1e-3

#create interval
observed_frequencies_bins = np.linspace(observed_frequencies.min()-epsilon, observed_frequencies.max()+epsilon, number_classes+1)
for p in range(0,number_classes+1):
    observed_frequencies_bins[p] = observed_frequencies_bins[p]
    
observed_digitized = np.digitize(observed_frequencies, observed_frequencies_bins) - 1


#initialization of contingency table
contingency_table = np.zeros((number_classes), dtype=int)

#fill the contengency table
for i in range(size):
    contingency_table[observed_digitized[i]] += 1


#compute the theoretical frequencies that we expect
expected_frequencies = np.zeros(number_classes)

expected_frequencies = np.array([(stats.norm.cdf(observed_frequencies_bins[i+1], loc=mu, scale=sigma) - 
                                  stats.norm.cdf(observed_frequencies_bins[i], loc=mu, scale=sigma)) * size
                                 for i in range(number_classes)])

print(expected_frequencies)
total_observed = np.sum(contingency_table)
expected_frequencies_adjusted = expected_frequencies * total_observed / np.sum(expected_frequencies)


#make the test : #ddof = number of estimated parameters
chi_square_statistic, p_value = stats.chisquare(f_obs=contingency_table, f_exp=expected_frequencies_adjusted,ddof=2)

print("______________________ CLASSES ______________________")
print()
print(observed_frequencies_bins)
print()
print("______________________ TABLE OF EMPIRICAL HEADCOUNTS ______________________")
print()
print(contingency_table)
print()
print("______________________ TABLE OF THEORETICAL HEADCOUNTS ______________________")
print()
print(expected_frequencies)
print()
print("-> mu = ",mu)
print("-> var = ",var)
print("-> Chi-square statistic = ", chi_square_statistic)
print("-> P-value = ", p_value)

alpha = 0.05  # Niveau de risque de 5%
degrees_of_freedom = number_classes - 2 - 1 #2 because we estimate mu and sigma 
print("-> Degree of freedom = ", degrees_of_freedom)
chi_square_critical_value = stats.chi2.ppf(1 - alpha, degrees_of_freedom)
print("-> Chi-square critical value = ", chi_square_critical_value)

if (chi_square_statistic < chi_square_critical_value):
    print("-> Failure to reject H0 : X follows a Gaussian Distribution")
else:
    print("-> Reject of H0 : X don't follows a Gaussian Distribution")








# # Cr√©er un Q-Q plot
(stats.probplot(observed_frequencies, dist="norm", plot=plt))

# Afficher le graphique
plt.title("Q-Q Plot")
plt.ylabel('Empirical Quantiques')
plt.xlabel('Theoretical Quantiles $\\mathcal{N}(0,1)$')
plt.grid()
#plt.show()

